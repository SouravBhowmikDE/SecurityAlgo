package AESALGORITHM_192;

/**
 * file: AESChiper.java author: SivaChintapalli & Sourav Bhowmik course:
 * MSCS_630L_231_16S assignment: Lab 2 due date: March 31, 2016 version: 1.0
 * This file contains the methods to perform the operations of AES Algorithm
 */
import java.util.HashMap;

/**
 * AESCipher AESCipher class perform the operations and generates the round keys
 * and shift operation, nibble Substitution and mixColums
 *
 * @author SIVARAMAKRISHNAPRASA & SOURAV BHOWMIK
 */
public class AESCipher {

    public static HashMap<Integer, Integer> sBox = new HashMap<>();
    public static HashMap<Integer, String> roundkeys = new HashMap<>();
    public static HashMap<Integer, Integer> Inverse_SBox = new HashMap<>();
    //storing the lookup table of S-box in to SboxArray
    public static Integer[] sBoxArray = {
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    };

    //Rcon stores the round constant look up table
    public static Integer[] rCon = {
        0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
        0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
        0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
        0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
        0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
        0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
        0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
        0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
        0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
        0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
        0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
        0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
        0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
        0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
        0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
    };
    /**
     * Galois look up table for the multiplication by 2
     */
    public static int[][] multiplyby2 = {
        {0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e},
        {0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e},
        {0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e},
        {0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e},
        {0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e},
        {0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe},
        {0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde},
        {0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe},
        {0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05},
        {0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25},
        {0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45},
        {0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65},
        {0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85},
        {0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5},
        {0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5},
        {0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5}};

    /**
     * Galois look up table for the multiplication by 3
     */
    public static int[][] multiplyby3 = {
        {0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11},
        {0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21},
        {0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71},
        {0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41},
        {0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1},
        {0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1},
        {0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1},
        {0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81},
        {0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a},
        {0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba},
        {0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea},
        {0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda},
        {0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a},
        {0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a},
        {0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a},
        {0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a}};
    /**
     * Galois fields of circulant matrix
     */
    public static int[][] mixColumn = {
        {0x02, 0x03, 0x01, 0x01},
        {0x01, 0x02, 0x03, 0x01},
        {0x01, 0x01, 0x02, 0x03},
        {0x03, 0x01, 0x01, 0x02}
    };

    public static Integer[] inv_SBoxArray = {
        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
    };
    private static int[][] mc9 = {
        {0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77},
        {0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7},
        {0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c},
        {0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc},
        {0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01},
        {0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91},
        {0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a},
        {0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa},
        {0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b},
        {0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b},
        {0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0},
        {0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30},
        {0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed},
        {0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d},
        {0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6},
        {0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46}};

    private static int[][] mc11 = {
        {0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69},
        {0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9},
        {0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12},
        {0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2},
        {0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f},
        {0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f},
        {0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4},
        {0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54},
        {0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e},
        {0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e},
        {0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5},
        {0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55},
        {0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68},
        {0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8},
        {0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13},
        {0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3}};

    private static int[][] mc13 = {
        {0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b},
        {0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b},
        {0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0},
        {0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20},
        {0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26},
        {0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6},
        {0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d},
        {0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d},
        {0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91},
        {0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41},
        {0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a},
        {0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa},
        {0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc},
        {0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c},
        {0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47},
        {0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97}};

    private static int[][] mc14 = {
        {0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a},
        {0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba},
        {0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81},
        {0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61},
        {0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7},
        {0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17},
        {0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c},
        {0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc},
        {0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b},
        {0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb},
        {0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0},
        {0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20},
        {0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6},
        {0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56},
        {0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d},
        {0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d}};

    private static final int[][] InverseMixColumn = {
        {0x0e, 0x0b, 0x0d, 0x09},
        {0x09, 0x0e, 0x0b, 0x0d},
        {0x0d, 0x09, 0x0e, 0x0b},
        {0x0b, 0x0d, 0x09, 0x0e}
    };

    /**
     * This method is used to return the Hex transformed value of S-box
     *
     * @param inHex is a input for S-box to transform the value
     * @return hexadecimal value from the S-box
     */
    protected Integer aesSBox(Integer inHex) {
        return sBox.get(inHex);
    }

    /**
     * This method returns round constant from R-Con look up table
     *
     * @param round is constant number
     * @return the transformed value from RCOn lookup table
     */
    protected Integer aesRCon(Integer round) {
        return rCon[round];
    }

    /**
     * This method is used to generate 11 round key from the encryption key
     *
     * @param keyHex is the Encryption key
     * @return HashMap with round keys
     */
    public HashMap<Integer, String> aesRoundKey(String keyHex) {
        // storing the sbox values in to HashMap for retrieving the values
        for (int i = 0x00; i <= 0xff; i++) {
            sBox.put(i, sBoxArray[i]);
        }
        // storing the Inverse-sbox values in to HashMap for retrieving the values 
        for (int i = 0x00; i <= 0xff; i++) {
            Inverse_SBox.put(i, inv_SBoxArray[i]);
        }
        //storing the input key into ke[4*4] ,ke[4*6] or ke[4*8] matrix
        Integer[][] ke = aesKey(keyHex);
        // w stores 11 round keys
        Integer[][] W = null;
        int row = 4;
        int columns = 0;
        if (keyHex.length() == 48) {
            W = new Integer[4][54];
            columns = keyHex.length() / 8;
        }
        if (keyHex.length() == 64) {
            W = new Integer[4][60];
            columns = keyHex.length() / 8;
        }
        if (keyHex.length() == 32) {
            W = new Integer[4][44];
            columns = keyHex.length() / 8;
        }
        // adding first four rows to W
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < columns; j++) {
                W[i][j] = ke[i][j];
            }
        }
        for (int j = columns; j < (W[0].length); j++) {
            // Array x[4] is used to store the values of j-4 column 
            Integer[] x = new Integer[4];
            // Array y[4] is used to store the values of j-4 column 
            Integer[] y = new Integer[4];
            Integer[] w;

            for (int k = 0; k < 4; k++) {
                //adding the W[k][][j-4] column values in to an array x[4]
                x[k] = W[k][j - columns];
                //adding the W[k][][j-1] column values in to an array y[4]
                y[k] = W[k][j - 1];
            }
            if (j % columns == 0) {
                //Wnew is a temporary vector
                Integer[] Wnew = new Integer[4];
                //Left Shifting Wnew by 1
                for (int r = 0; r < 4; r++) {
                    int leftShift = r + 1;
                    if (r == 3) {
                        leftShift = r - 3;
                    }
                    Wnew[r] = y[leftShift];
                }
                //Transforming Wnew using Sbox
                for (int r = 0; r < 4; r++) {
                    Wnew[r] = aesSBox(Wnew[r]);
                }
                //Calculating Round number and storing in RoundNo
                int RoundNo = j / columns;
                //Xoring round constant with Wnew[0]
                Wnew[0] ^= aesRCon(RoundNo);

                w = xor(x, Wnew);
                for (int i = 0; i < 4; i++) {
                    W[i][j] = w[i];
                }
            } else //This snippet is only for 256-bits Round Key generation
            // If j is a multiple of 4 and not a multiple of 8.
            {
                if (j % 4 == 0 && W[0].length == 60) {
                    // Copy the previous column into a temporary storage area
                    for (int r = 0; r < 4; r++) {   // Perform the S-box substitution
                        y[r] = aesSBox(y[r]);
                    }
                    w = xor(x, y);
                    for (int i = 0; i < 4; i++) {
                        W[i][j] = w[i];
                    }
                } else {
                    w = xor(x, y);
                    for (int i = 0; i < 4; i++) {
                        W[i][j] = w[i];
                    }
                }
            }
        }

        int counter = 1;
        String roundKey = "";
        //Adding the 11, 13, or 15 round keys in to HashMap roundKeys

        int k = 0;
        int j;
        int x = W[0].length;
        for (j = 0; j < x; j++) {
            for (int i = 0; i < 4; i++) {
                if (counter % 16 == 0) {
                    roundKey += String.format("%02X", W[i][j]);
                    int round = counter / 16;
                    roundkeys.put(round, roundKey);
                    roundKey = "";
                } else {
                    roundKey += String.format("%02X", W[i][j]);

                }
                counter++;
            }
        }

        return roundkeys;
    }

    /**
     * This method converts the key from String to hexadecimal Integer array.
     *
     * @param key is an encryption key
     * @return a 4*4 matrix of encryption key in hexadecimal
     */
    protected Integer[][] aesKey(String key) {
        int blockSize = key.length();
        int size = blockSize / 8;
        int row = 4;
        int coloumn = size;
        Integer[][] ke = new Integer[row][coloumn];
        for (int i = 0; i < coloumn; i++) {

            for (int j = 0; j < row; j++) {
                // copying  input key into 4*4 matrix
                String val = String.valueOf(key.charAt((row * i) * 2 + j * 2) + ""
                        + key.charAt((row * i) * 2 + j * 2 + 1));
                ke[j][i] = Integer.parseInt(val, 16);

            }
        }
        return ke;

    }

    /*
   * This function bitwise xors elements of two 1D matrices with 4 elements each
   * @param Vector1 is the first matrix
   * @param Vector2 is the second vector
   * @return ResultantVector is the xor result
     */
    protected Integer[] xor(Integer Vector1[], Integer Vector2[]) {
        Integer[] ResultantVector = new Integer[4];
        for (int i = 0; i < 4; i++) {
            ResultantVector[i] = Vector1[i] ^ Vector2[i];
        }
        return ResultantVector;
    }

    /**
     * This method is used to convert the key and message in to the 4*4 matrix
     *
     * @param key is a parameter which will be converting in to matrix form
     * @return key in the form of Integer 4*4 matrix
     */
    protected Integer[][] matrics(String key) {
        int row = 4;
        int coloumn = 4;
        Integer[][] ke = new Integer[row][coloumn];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < coloumn; j++) {
                // coping  input key into 4*4 matrix
                String val = String.valueOf(key.charAt((coloumn * i) * 2 + j * 2) + ""
                        + key.charAt((coloumn * i) * 2 + j * 2 + 1));
                ke[j][i] = Integer.parseInt(val, 16);
            }
        }

        return ke;

    }

    /**
     * This method is used to perform the XOR operation on round-key and message
     *
     * @param sHex is the message which is need to encrypt
     * @param keyHex is the round key
     * @return xorResult is the XOR result of key and message in Integer 4*4
     * matrix
     */
    protected Integer[][] aesStateXOR(String sHex, String keyHex) {
        Integer[][] key = matrics(keyHex);
        Integer[][] msg = matrics(sHex);
        Integer[] keyTemp = new Integer[4];
        Integer[] msgTemp = new Integer[4];
        Integer[][] xorResult = new Integer[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                keyTemp[j] = key[i][j];
                msgTemp[j] = msg[i][j];

            }
            xorResult[i] = xor(keyTemp, msgTemp);
        }
        return xorResult;
    }

    /**
     * This method is used to perform the nibble substitution using S-Box
     *
     * @param inStateHex is the XOR result of the round key and message
     * @return outStateHex which is the result of nibbleSubstution in 4*4 matrix
     */
    protected Integer[][] aesNibbleSub(Integer[][] inStateHex) {
        Integer[][] outStateHex = new Integer[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                outStateHex[i][j] = aesSBox(inStateHex[i][j]);
            }
        }
        return outStateHex;
    }

    /**
     * This method is used to perform the left Shifting the values in the matrix
     *
     * @param inStateHex is the result of nibble substitution to perform the
     * shift
     * @return leftShiftMatrics is the result of leftShift of the 4*4 matrix
     */
    protected Integer[][] aesShiftRow(Integer[][] inStateHex) {
        int leftShift;
        Integer[][] leftShiftMatrics = new Integer[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                leftShift = j + i;
                if (i == 1 && j == 3) {
                    leftShift = j - 3;
                }
                if (i == 2 && j >= 2) {
                    leftShift = j - 2;
                }
                if (i == 3 && j >= 1) {
                    leftShift = j - 1;
                }
                leftShiftMatrics[i][j] = inStateHex[i][leftShift];
            }
        }
        return leftShiftMatrics;
    }

    /**
     * This method is used to do the mixColumn operation
     *
     * @param array is the Input to perform the mixColumn operation
     * @return tempArray is the result of mixColumn operation
     */
    protected Integer[][] aesMixColumn(Integer[][] array) {
        Integer[][] mixedColumnMatrix = new Integer[4][4];
        String message = "";
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                mixedColumnMatrix[i][j] = mixColumnCalc(array, mixColumn, i, j);
            }
        }
        return mixedColumnMatrix;
    }

    /**
     * This method help to perform the sum of the values of the multiplication
     * of two values
     *
     * @param array is the AES Left-Shift matrix
     * @param mclmn is Galois matrix
     * @param i is the row value of the Matrix
     * @param j is colum value of the matrix
     * @return sum after performing the multiplication of one row and column of
     * matrices
     */
    protected int mixColumnCalc(Integer[][] array, int[][] mclmn, int i, int j) {
        int sum = 0;
        for (int k = 0; k < 4; k++) {
            int a = mclmn[i][k];
            int b = array[k][j];
            sum ^= mcMultiplication(a, b);
        }
        return sum;

    }

    /**
     * This method helps to multiplying the values by 1,2,3
     *
     * @param a element of Galois matrix
     * @param b element of AES Matrix
     * @return values after multiplication by 1,2,3,0
     */
    protected int mcMultiplication(int a, int b) {
        if (a == 1) {
            return b;
        } else if (a == 2) {
            return multiplyby2[b / 16][b % 16];
        } else if (a == 3) {
            return multiplyby3[b / 16][b % 16];
        }
        return 0;
    }

    /**
     * This method is used to return the Hex transformed value of S-box
     *
     * @param inHex is a input for S-box to transform the value
     * @return hexadecimal value from the S-box
     */
    protected Integer aesInverseSBox(Integer inHex) {
        return Inverse_SBox.get(inHex);
    }

    /**
     * This method substitutes the matrix values from inverse S-Box
     *
     * @param inStateHex: is the input 4*4 matrix
     * @return: substituted matrix
     */
    protected Integer[][] aesInverseNibbleSub(Integer[][] inStateHex) {
        Integer[][] outStateHex = new Integer[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                outStateHex[i][j] = aesInverseSBox(inStateHex[i][j]);
            }
        }
        return outStateHex;
    }

    /**
     * This method is used to perform the right Shifting the values in the
     * matrix
     *
     * @param inStateHex: the input matrix on which shift has to be performed
     * @return leftShiftMatrics is the result of right Shift.
     */
    protected Integer[][] aesInverseShiftRow(Integer[][] inStateHex) {
        int righttShift;
        Integer[][] righttShiftMatrics = new Integer[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                righttShift = j - i;
                if (i == 1 && j == 0) {
                    righttShift = j + 3;
                }
                if (i == 2 && j <= 1) {
                    righttShift = j + 2;
                }
                if (i == 3 && j <= 2) {
                    righttShift = j + 1;
                }
                righttShiftMatrics[i][j] = inStateHex[i][righttShift];
            }
        }
        return righttShiftMatrics;
    }

    /**
     * This method is used to do the Inverse mixColumn operation
     *
     * @param array is the Input array to perform the inverse mixColumn
     * operation
     * @return tempArray is the result of mixColumn operation
     */
    protected Integer[][] aesInverseMixColumn(Integer[][] array) {
        Integer[][] tempArray = new Integer[4][4];
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                tempArray[i][j] = inverseMixColumnCalc(array, InverseMixColumn, i, j);
            }
        }
        return tempArray;
    }

    /**
     * This method help to perform the sum of the values of the multiplication
     * of two values
     *
     * @param array is the AES Left-Shift matrix
     * @param mclmn is Galois matrix
     * @param i is the row value of the Matrix
     * @param j is colum value of the matrix
     * @return sum after performing the multiplication of one row and column of
     * matrices
     */
    protected int inverseMixColumnCalc(Integer[][] array, int[][] mclmn, int i, int j) {
        int sum = 0;
        for (int k = 0; k < 4; k++) {
            int a = mclmn[i][k];
            int b = array[k][j];
            sum ^= inverseMCMultiplication(a, b);
        }
        return sum;

    }

    /**
     * This method helps to multiplying the values by 9, 11, 13, 14
     *
     * @param a element of Galois matrix
     * @param b element of AES Matrix
     * @return values after multiplication by 9, 11, 13, 14.
     */
    private int inverseMCMultiplication(int a, int b) //Helper method for invMcHelper
    {
        if (a == 9) {
            return mc9[b / 16][b % 16];
        } else if (a == 0x0b) {
            return mc11[b / 16][b % 16];
        } else if (a == 0x0d) {
            return mc13[b / 16][b % 16];
        } else if (a == 0x0e) {
            return mc14[b / 16][b % 16];
        }
        return 0;
    }

    /*
    This method encrypts a message
    @param message: input string message
    @return: encrypted message
     */
    public String encryption(String message) {
        Integer[][] outStateXor = new Integer[4][4];
        Integer[][] outStateNibble = new Integer[4][4];
        Integer[][] outStateShiftRow = new Integer[4][4];
        Integer[][] mixColumn = new Integer[4][4];
        String plainText = message;
        AESCipher aesChiper = new AESCipher();
        String cipherText = "";
        for (int i = 1; i <= roundkeys.size(); i++) {
//         addKey values will be stored in the outStateXor for every roundkey
            outStateXor = aesChiper.aesStateXOR(plainText, roundkeys.get(i));
            if (i <= roundkeys.size() - 1) {
                // nibble Substitution value of the addkey will be stored in outStateNibble
                outStateNibble = aesChiper.aesNibbleSub(outStateXor);
                /*
         after performing  the left shift on the rows the result is stored in 
         to the outStateShiftRow
                 */
                outStateShiftRow = aesChiper.aesShiftRow(outStateNibble);
            }
            if (i <= roundkeys.size() - 2) {
                /*
         after performing the aesMixColumn the valu willbe store in to mixColumn
                 */
                mixColumn = aesChiper.aesMixColumn(outStateShiftRow);
            }
            plainText = "";
            for (int k = 0; k < 4; k++) {
                for (int j = 0; j < 4; j++) {
                    if (i <= roundkeys.size() - 2) {
                        plainText += String.format("%02X", mixColumn[j][k]);
                    } else {
                        plainText += String.format("%02X", outStateShiftRow[j][k]);
                    }
                }
            }
        }
        for (int k = 0; k < 4; k++) {
            for (int j = 0; j < 4; j++) {
                cipherText += String.format("%02X", outStateXor[j][k]);
            }
        }
        return cipherText;
    }

    /*
    This method decrypts a message
    @param message: encrypted String message
    @return: decrypted String message
     */
    public String decryption(String message) {
        Integer[][] outStateXor = new Integer[4][4];
        Integer[][] outStateNibble = new Integer[4][4];
        Integer[][] outStateShiftRow = new Integer[4][4];
        Integer[][] mixColumn = new Integer[4][4];
        String plainText = message;
        AESCipher aesChiper = new AESCipher();
        for (int i = roundkeys.size(); i >= 1; i--) {
            //  addKey values will be stored in the outStateXor for every roundkey
            outStateXor = aesChiper.aesStateXOR(plainText, roundkeys.get(i));
            if (i <= roundkeys.size() && i > 1) {
                if (i == roundkeys.size()) {
                    outStateShiftRow = aesChiper.aesInverseShiftRow(outStateXor);
                } else {
                    // after performing the aesMixColumn the valu willbe store in to mixColumn

                    mixColumn = aesChiper.aesInverseMixColumn(outStateXor);
                   // after performing  the right shift on the rows the result is stored in to the outStateShiftRow
                    outStateShiftRow = aesChiper.aesInverseShiftRow(mixColumn);
                }
                // Inverse nibble Substitution value of the addkey will be stored in outStateNibble
                outStateNibble = aesChiper.aesInverseNibbleSub(outStateShiftRow);
                plainText = "";
                for (int k = 0; k < 4; k++) {
                    for (int j = 0; j < 4; j++) {
                        plainText += String.format("%02X", outStateNibble[j][k]);
                    }
                }
            }
        }
        String cipherText = "";
        for (int k = 0; k < 4; k++) {
            for (int j = 0; j < 4; j++) {
                cipherText += String.format("%02X", outStateXor[j][k]);
            }
        }
        return cipherText;
    }
}
